Topi-1  Pre-requisite

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Birthday  Pardox

<Link for video solution>
<link for Textual Explanation>
1.) https://en.wikipedia.org/wiki/Birthday_problem
2.) https://en.wikipedia.org/wiki/Birthday_attack
3.) https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind
4.) https://en.wikipedia.org/wiki/Knapsack_problem
5.) https://en.wikipedia.org/wiki/Cutting_stock_problem; https://en.wikipedia.org/wiki/List_of_knapsack_problems; https://en.wikipedia.org/wiki/Packing_problems
6.) https://en.wikipedia.org/wiki/Continuous_knapsack_problem; https://en.wikipedia.org/wiki/Change-making_problem; https://en.wikipedia.org/wiki/Combinatorial_auction
7.) 

code:
1). C++ :
// C++ program to approximate number of people in Birthday Paradox  
// problem 
#include <cmath> 
#include <iostream> 
using namespace std; 
  
// Returns approximate number of people for a given probability 
int find(double p) 
{ 
    return ceil(sqrt(2*365*log(1/(1-p)))); 
} 
  
int main() 
{ 
   cout << find(0.70); 
} 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.)Python :
# Python3 code to approximate number 
# of people in Birthday Paradox problem 
import math 

# Returns approximate number of 
# people for a given probability 
def find( p ): 
	return math.ceil(math.sqrt(2 * 365 *
					math.log(1/(1-p)))); 

# Driver Code 
print(find(0.70))

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Big Integer Problems

<link for video solution>
<link for textual explanation>
1.) https://www.geeksforgeeks.org/factorial-large-number
2). https://www.geeksforgeeks.org/biginteger-class-in-java
3.) https://www.geeksforgeeks.org/find-the-length-of-factorial-of-a-number-in-any-given-base/?ref=rp

<Additional Resources needed>
1.) https://dev.to/remonhasan/kamenetsky-s-algorithm-3gj9        	(For number of digits in a factorial)
                                        f(x) =    log10( ((n/e)^n) * sqrt(2*pi*n))

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.) Problem to find last digit of a factorial in any base ( Kamenetsky Algorithm )

C++ code:
// A optimised program to find the 
// number of digits in a factorial in base b 
#include <bits/stdc++.h> 
using namespace std; 

// Returns the number of digits present 
// in n! in base b Since the result can be large 
// long long is used as return type 
long long findDigits(int n, int b) 
{ 
	// factorial of -ve number 
	// doesn't exists 
	if (n < 0) 
		return 0; 

	// base case 
	if (n <= 1) 
		return 1; 

	// Use Kamenetsky formula to calculate 
	// the number of digits 
	double x = ((n * log10(n / M_E) + 
				log10(2 * M_PI * n) / 
				2.0)) / (log10(b)); 

	return floor(x) + 1; 
} 

// Driver Code 
int main() 
{ 
	//calling findDigits(Number, Base) 
	cout << findDigits(4, 16) << endl; 
	cout << findDigits(5, 8) << endl; 
	cout << findDigits(12, 16) << endl; 
	cout << findDigits(19, 13) << endl; 
	return 0; 
} 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Python code:
from math import log10,floor 

# A optimised program to find the 
# number of digits in a factorial in base b 

# Returns the number of digits present 
# in n! in base b Since the result can be large 
# long long is used as return type 
def findDigits(n, b): 
	
	# factorial of -ve number 
	# doesn't exists 
	if (n < 0): 
		return 0
	
	M_PI = 3.141592
	M_E = 2.7182

	# base case 
	if (n <= 1): 
		return 1

	# Use Kamenetsky formula to calculate 
	# the number of digits 
	x = ((n * log10(n / M_E) + log10(2 * M_PI * n) / 2.0)) / (log10(b)) 

	return floor(x) + 1

# Driver Code 
if __name__ == '__main__': 
	
	#calling findDigits(Number, Base) 
	print(findDigits(4, 16)) 
	print(findDigits(5, 8)) 
	print(findDigits(12, 16)) 
	print(findDigits(19, 13)) 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 2.)MDAS factorial Problem (Factorial with a twist) 
 
 Naive Algo speed = O(N)    Best Speed = O(1)
 Example= MDAS factorial of N=N!=N*(N-1)/(N-2)+(N-3)-(N-4)...... upto 1
 
If we observe carefully it can be concluded that:

--If N is less than or equal to 2 then answer will be N itself.
--If N is 3 OR N is 4, the answer is N + 3.
--If (N – 4) is completely divisible by 4, the answer is N + 1.
--If (N – 4) gives remainder 1 OR 2 while dividing by 4, the answer is N + 2.
--For the remaining values, the answer will be N – 1

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.) C++ code:-

// C++ Program to find MDAS_Factorial 
#include <bits/stdc++.h> 
using namespace std; 

// Program to find MDAS_factorial 
int MDAS_Factorial(int N) 
{ 
	if (N <= 2) 
		return N; 

	if (N <= 4) 
		return (N + 3); 

	if ((N - 4) % 4 == 0) 
		return (N + 1); 

	else if ((N - 4) % 4 <= 2) 
		return (N + 2); 

	else
		return (N - 1); 
} 

// Driver code 
int main() 
{ 

	int N = 4; 
	cout << MDAS_Factorial(N) << endl; 
	N = 10; 
	cout << MDAS_Factorial(N) << endl; 

	return 0; 
} 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.) Python code:-

# Python3 code find MDAS_Factorial 
def MDAS_Factorial( N ): 
	
	if N <= 2: 
		return N 

	if N <= 4: 
		return N + 3
		
	if (N - 4) % 4 == 0: 
		return N + 1

	elif (N - 4) % 4 <= 2: 
		return N + 2

	else: 
		return N - 1

# Driver code 
N = 4
print(MDAS_Factorial( N ) ) 

N = 10
print(MDAS_Factorial( N ) ) 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Prime Numbers

<link for video solution>
<link for textual expalnation of problems>

